<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>展示端</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto;text-align:center;padding:24px}
  img{max-width:min(90vw,90vh);height:auto;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.08)}
  pre{max-width:960px;margin:16px auto;text-align:left;background:#111;color:#0f0;padding:12px;border-radius:8px}
</style>

<h1>当前图片</h1>
<img id="mainImg" alt="loading..." />
<pre id="log"></pre>

<!-- Socket.IO v4 客户端（CDN） -->
<script src="https://cdn.socket.io/4.7.4/socket.io.min.js" crossorigin="anonymous"></script>
<script>
  const SERVER = "https://www.ljlcszy.cn:8443";                 // 你的后端域名（走 HTTPS）
  const DEFAULT_IMG = "https://kingterljl.github.io/test/images/cs.jpg";
  const imgEl = document.getElementById('mainImg');
  const logEl = document.getElementById('log');

  function logLine(...a){ logEl.textContent += a.join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; }

  // 仅当 url 真变化时才换，避免多余重绘
  let lastBase = null;
  function swapImage(baseUrl){
    if (!baseUrl) return;
    // 再加一层前端 cache-buster（即使后端没带 ?t= 也能强制刷新）
    const final = baseUrl + (baseUrl.includes('?') ? '&' : '?') + 'cb=' + Date.now();

    if (final === imgEl.src) {
      logLine('== same URL, skip ==');
      return;
    }
    const pre = new Image();
    pre.onload = () => {
      imgEl.src = final;
      logLine('>> swapped to', final);
    };
    pre.onerror = (e) => {
      logLine('!! preload failed', final, e && (e.message || e));
    };
    pre.src = final;
    lastBase = baseUrl;
  }

  // 1) 首次拉取当前状态
  fetch(`${SERVER}/api/current`, { cache: 'no-store' })
    .then(r => r.json())
    .then(s => {
      logLine('GET /api/current ->', JSON.stringify(s));
      swapImage((s && s.img) || DEFAULT_IMG);
    })
    .catch(e => { logLine('GET /api/current FAIL', e); swapImage(DEFAULT_IMG); });

  // 2) 订阅推送（用 /wsio/）
  const socket = io(SERVER, {
    path: "/wsio/",                         // 必须与后端 SocketIO path 或 Nginx 映射一致
    transports: ["websocket","polling"],    // 优先 WebSocket
    reconnection: true
  });

  // 确保不会重复绑定
  socket.off && socket.off("update_image");

  socket.on("connect",       () => logLine("[display] socket connected", socket.id));
  socket.on("connect_error", e  => logLine("[display] connect_error", e && (e.message || e)));
  socket.on("error_msg",     e  => logLine("[server error]", JSON.stringify(e)));

  socket.on("update_image", (s) => {
    logLine("[display] update_image", JSON.stringify(s));
    const next = s && (s.img || s.url);     // 兼容两种字段
    if (!next) return;
    // 混合内容检测：HTTPS 页面必须加载 HTTPS 图片
    if (location.protocol === 'https:' && next.startsWith('http://')) {
      logLine('!! Mixed Content blocked:', next);
      return;
    }
    // 如果服务端两次给的 base 一样，仍会换，因为我们追加了 cb=
    swapImage(next);
  });
</script>
